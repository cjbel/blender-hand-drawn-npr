% 4-5 pages total.

% Goals:
% System architecture major design decisions and rationale.
% Implementation details (~1 page).
% Screenshots or other similar things (~1 page).
% Additional details; eg design diagrams in the Appendix.

% Marking:
% Is the software product well-designed, functional, reliable, robust, efficient, usable, maintainable, and well-documented? Has it been demonstrated?
% A-band: The software product is extremely well designed, implemented, and documented.

\chapter{Design \& Implementation}\label{design_implementation}

\section{Technical Background: Cycles Render Passes}

A 2D image produced by the Cycles rendering engine can be considered a composite of multiple ``lighting passes''.
According to scene geometry, light sources and surface materials, the engine must compute the effects of direct/indirect diffuse light, direct/indirect specular light, shadow etc.
Similarly, ``data passes'' capture surface normals, depth information, and UV texture-coordinates.
Lighting and data passes can themselves be expressed as images and written to disk.
The typical use-case for this functionality is post-processing of render scenes, where compositing software is used to combine passes in different ways to affect characteristics of the final rendering.

For this project however, selected render passes are post-processed directly with Python, and used to inform placement of strokes through image-space stroke-based rendering techniques. As such, the System builds directly on render passes produced by the Cycles engine in Blender, and these images form the fundamental input to the System.

\section{System Flow}

% Talk about big-picture flow, should set the scene for architecture and domain model.

System flow is depicted in Appendix \ref{}.

\section{Platform Considerations \& System Architecture}
% - Design for blender plugin (multifile).
% - Separation of blender-specific from backend.
% - Design considerations for testing (brief, cover testing in next section).
% - Levels of abstraction between modules.

Blender ships with an embedded Python interpreter\footnote{\url{https://docs.blender.org/api/2.79/info_overview.html}}, allowing arbitrary scripts to be executed within the Blender environment.
Blender's powerful Python API\footnote{\url{https://docs.blender.org/api/2.79/}} (specifically the \texttt{bpy} module), exposes session/scene data, allows automation of built-in functionality, and enables creation of UI elements.

Trivial scripts can be pasted into and executed from the built-in Python shell or editor, however good practice\footnote{\url{https://docs.blender.org/api/2.79/info_overview.html#script-loading}} dictates that more complex systems be encapsulated as a multi-file package{\footnote{\url{https://blender.stackexchange.com/questions/44532/best-practice-for-add-on-generation-with-many-functions-single-file-or-split-it}}.
To encourage distribution of useful modules, Blender provides a convenient ``add-on'' subsystem, which allows packages to be easily installed and toggled via the GUI.

An add-on is essentially a regular Python package, with two key additional requirements. 
The top-level package \texttt{\_\_init\_\_.py} must contain package metadata\footnote{\url{https://wiki.blender.org/wiki/Process/Addons/Guidelines/metainfo}}, and must implement \texttt{register()} and \texttt{unregister()} methods.
These methods allow the add-on subsystem to toggle visibility of contained classes within the Blender environment.

Beyond these simple requirements, no constraints are placed on compatible system architectures. 
Dependence on the \texttt{bpy} module however has practical implications for design and development.
\texttt{bpy} is shipped built-in to the embedded environment, and is not accessible outside of a running Blender session\footnote{At least not without complex and poorly documented workarounds: \url{https://blender.stackexchange.com/questions/102933/a-working-guidance-for-building-blender-as-bpy-python-module}}.
Indeed, the role of \texttt{bpy} is to query and alter the internal state of a Blender session, and has no functional use outside of this session (as would be the case when developing code in an IDE operating in a virtual environment).

This is generally not a concern for trivial systems where development and testing can be performed within Blender's simple script editor.
Due to the anticipated complexity of this System however, the power of an IDE was preferred (specifically debugging and re-factoring capabilities).

As such, a design decision was taken to de-couple \texttt{bpy} from as much of the application code as possible.
This was achieved by implementing a Model-View-Controller arrangement. 
The \texttt{View-Controller} contains code with dependencies on \texttt{bpy}, which must run/tested within the clunky Blender environment. 
This is limited to essential add-on plumbing, GUI creation, manipulation of user-space settings within Blender, and triggering of \texttt{Model} code. 
The \texttt{Model} is free of \texttt{bpy} dependencies, and is run/tested in an IDE and virtual environment. 
The majority of application code - including all image processing logic and SVG rendering - is contained in the \texttt{Model} which has no knowledge of the \texttt{View-Controller}, or the wider Blender environment.

This design enabled the majority of development to take place outside of Blender.
Core rendering functionality provided by the \texttt{Model} can be run directly, and strong de-coupling enables the backend \texttt{Model} to be used with 3D modelling packages other than Blender, provided the necessary input image data can be made available on disk.

The System architecture diagram is presented in Appendix \ref{}.

Some practical testing implications of this approach are discussed further in Section \ref{}.

\section{Domain Design}

The domain model diagram is presented in Appendix \ref{appendix_design}.

\subsection{View-Controller}

The \texttt{View-Controller} is the Blender-facing part of the System.

It is responsible for defining the GUI, adjusting Blender settings (e.g. enabling of required render passes).

The overall structure of this package is based upon the Cycles add-on itself - three main modules separate the \texttt{ui}, \texttt{properties} and \texttt{operators}.

\subsection{Model}

\section{Implementation Details \& Challenges}

\subsection{Silhouette}



\section{Demonstration}
% - UI.
% - Sample renders.
% - Performance.
